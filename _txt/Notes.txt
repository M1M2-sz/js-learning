Бинарный поиск

Поиск который использует метод половинчатого деления.
На пример, что бы найти случайно загаданное число от 1 до 100 понадобится в среднем 7 шагов!!!

А для числа 240 000 - можно будет реализовать этот поиск за 18 шагов!

Идея делить на половину полученный результат.

Пример: найти число от 1 до 100(загадаем число 7)
Метод нахождения:
	1. Это число больше 50? : нет (значит меньше)
	2. Это число больше 25? : нет (значит меньше)
	3. Это число больше 12? : нет (значит меньше)
	4. Это число больше 6?   : да   (значит между 6 и 12)
	5. Это число больше 9?   : нет (значит меньше - между 6 и 9)
	6. Это число больше 8?   : нет (значит меньше 8 - между 6 и 8)
	7. Это число 7?                   : да

Примечание: работает только с отсортированными и упорядоченными системами. С не отсортированными и не упорядоченными не работает. По крайней мере на столько эффективно.


Логарифмы

Структура противоположная возведению в степень (умножению n раз на само себя)

Примеры:
10^2 = 100                             log^10  100 = 2
10^3 = 1,000                          log^10  1000 = 3
2^3 = 8                                    log^2  8 = 3
2^4 = 16                                  log^2  16 = 4
2^5 = 32                                  log^2  32 = 5
2^10 = 1,024                          log^2  1,024 = 10
5^10 = 9,765,625                  log^5  9,765,625 = 10
66^4 = 18,974,736                lod^66  18,974,736 = 4

Логарифм позволяет высчитать сколько попыток понадобится для поиска числа бинарным методом.

Пример:

У нас есть число от 1 до 8 - и нам нужно узнать за сколько попыток мы найдем загаданное число в 8.
Решается просто:  
log^8 = 3      (2^3 = 8)
То есть за 3 попытки мы найдем нужное число.

Для числа от 1 до 1024 та же задача :
log^1,024 = 10  (2^10 = 1,024)
То есть за 10 попыток мы найдем нужное число в заданном диапазоне.

Пример алгоритма на python:

def binary_search(list, item):
    low = 0
    high = len(list) - 1

    while low <= high:
        mid = (low + high)
        guess = list[mid]

        if guess == item:
            return mid
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1
    return None

my_list = [1, 3, 5, 7, 9]

print(binary_search(my_list, 3)) # => 1
print(binary_search(my_list, -1)) # => None

Описание:
Функция на входе получает отсортированный массив и значение.
Если значение присутствует в массиве то функция возвращает его позицию.

Тест:
Имеется отсортированный список из 128 имен, и вы ищете в нем зна­ чение методом бинарного поиска. Какое максимальное количество проверок для этого может потребоваться?

Решение:
128 / 2 / 2 / 2 / 2 / 2 / 2 / 2 = 1 
Соответственно 2^7 = 128 

То есть за 7 попыток мы найдем нужное число.

Предположим, размер списка увеличился вдвое. Как изменится мак­ симальное количество проверок?

Решение:
256 / 2 / 2 / 2 / 2 / 2 / 2 / 2 / 2 = 1 
Соответственно 2^8 = 256 

То есть за 8 попыток мы найдем нужное число.
Присутствует закономерность - при увеличении в двое - количество попыток растет на 1.
Работет ли этот принцип всегда или только на определенных числах?

Проверяем:

512 / 2 / 2 / 2 / 2 / 2 / 2 / 2 / 2 / 2 = 1 
Соответственно 2^9 = 512 
То есть за 9 попыток мы найдем нужное число.

А если 2048 : (дожно получиться за 11 попыток - то есть 512 + 512  = 1 024 _ это + 1 попытка, и 1024 + 1024 = 2048 _ это еще + 1 попытка) 

Проверяем:

2048 / 2 / 2 / 2 / 2 / 2 / 2 / 2 / 2 / 2 / 2 / 2 = 1 
Соответственно 2^11 = 2,048 
То есть за 11 попыток мы найдем нужное число! 
Клас!
 
 
